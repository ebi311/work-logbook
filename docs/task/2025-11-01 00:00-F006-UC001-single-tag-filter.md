# タスク: F-006 UC-001 単一タグでの絞り込み実装

作成日時: 2025-11-01T00:00:00Z  
関連機能仕様: [F-006 タグでの絞り込み](../features/2025-11-01%2000:00-F006-tag-filter.md)

## 目的

作業一覧画面で、単一のタグによる絞り込み機能を実装する。ユーザーがタグ入力欄にタグを入力または選択すると、そのタグが付いた作業記録のみが表示される。

## ユースケース

**UC-001: タグで絞り込む（単一タグ）**

1. ユーザーが作業一覧画面を表示
2. フィルタバーのタグ入力欄にタグ名を入力（例: `開発`）
3. システムは過去に使用したタグをサジェスト表示
4. ユーザーがタグを選択またはEnterキーを押す
5. システムは該当するタグが付いた作業記録のみを表示
6. URLに `?tags=開発` が追加される
7. 選択されたタグがフィルタバーにバッジとして表示される

## 実装範囲

本タスクは以下のステップに分割して実装する:

1. **DB層の拡張**: タグフィルタ機能の追加
2. **タグ取得API**: ユーザーが使用した全タグのリスト取得
3. **Server Load の拡張**: URLパラメータからタグを取得し、DBに渡す
4. **UI実装**: タグ入力欄とバッジ表示
5. **統合テスト**: E2Eでの動作確認

---

## ステップ1: DB層の拡張

### 目的

`listWorkLogs` 関数にタグフィルタ機能を追加し、指定されたタグが付いている作業記録のみを取得できるようにする。

### 実装内容

#### 1.1 型定義の拡張

**ファイル**: `src/db/workLogs.ts`

```typescript
export type ListWorkLogsOptions = {
	from?: Date;
	to?: Date;
	tags?: string[]; // 追加: タグフィルタ
	limit: number;
	offset: number;
};
```

#### 1.2 `listWorkLogs` 関数の拡張

**ファイル**: `src/db/workLogs.ts`

タグフィルタ条件を追加:

```typescript
import { sql, and, eq, gte, lte, desc, inArray } from 'drizzle-orm';
import { workLogs, workLogTags } from './schema';

export const listWorkLogs = async (
	userId: string,
	options: ListWorkLogsOptions,
): Promise<WorkLog[]> => {
	const { from, to, tags, limit, offset } = options;

	let query = db
		.select({
			id: workLogs.id,
			userId: workLogs.userId,
			startedAt: workLogs.startedAt,
			endedAt: workLogs.endedAt,
			description: workLogs.description,
			createdAt: workLogs.createdAt,
			updatedAt: workLogs.updatedAt,
		})
		.from(workLogs)
		.where(eq(workLogs.userId, userId))
		.$dynamic();

	// 日付フィルタ（既存）
	const conditions = [eq(workLogs.userId, userId)];

	if (from) {
		conditions.push(gte(workLogs.startedAt, from));
	}
	if (to) {
		conditions.push(lte(workLogs.startedAt, to));
	}

	// タグフィルタ（新規）
	// 指定されたタグが全て付いている作業のみを取得
	if (tags && tags.length > 0) {
		const taggedWorkLogIds = db
			.select({ workLogId: workLogTags.workLogId })
			.from(workLogTags)
			.where(inArray(workLogTags.tag, tags))
			.groupBy(workLogTags.workLogId)
			.having(sql`COUNT(DISTINCT ${workLogTags.tag}) = ${tags.length}`)
			.as('tagged_work_log_ids');

		conditions.push(inArray(workLogs.id, sql`(SELECT work_log_id FROM ${taggedWorkLogIds})`));
	}

	query = query.where(and(...conditions));

	// 並び順・ページング
	const rows = await query.orderBy(desc(workLogs.startedAt)).limit(limit).offset(offset);

	// タグの取得とWorkLogオブジェクトの構築
	return await Promise.all(
		rows.map(async (row) => {
			const tagsList = await getWorkLogTags(row.id);
			return WorkLog.reconstruct({ ...row, tags: tagsList });
		}),
	);
};
```

**注意**: Drizzle ORMの具体的なAPIに応じて、サブクエリの書き方を調整する必要がある場合があります。

### テスト

#### UT-1.1: 単一タグでのフィルタリング

**ファイル**: `src/db/workLogs.spec.ts`

```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { listWorkLogs } from './workLogs';
import { createWorkLog } from './workLogs';
import { addWorkLogTag } from './workLogTags';
import { db } from './client';
import { workLogs, workLogTags } from './schema';
import { eq } from 'drizzle-orm';

describe('listWorkLogs - タグフィルタ', () => {
	const userId = 'test-user-tag-filter';
	const workLogIds: string[] = [];

	beforeEach(async () => {
		// テストデータの作成
		// 作業1: タグ「開発」
		const workLog1 = await createWorkLog(userId, {
			startedAt: new Date('2025-11-01T09:00:00Z'),
			endedAt: new Date('2025-11-01T11:00:00Z'),
			description: '機能実装',
		});
		await addWorkLogTag(workLog1.id, '開発');
		workLogIds.push(workLog1.id);

		// 作業2: タグ「会議」
		const workLog2 = await createWorkLog(userId, {
			startedAt: new Date('2025-11-01T13:00:00Z'),
			endedAt: new Date('2025-11-01T14:00:00Z'),
			description: '定例ミーティング',
		});
		await addWorkLogTag(workLog2.id, '会議');
		workLogIds.push(workLog2.id);

		// 作業3: タグ「開発」「PJ-A」
		const workLog3 = await createWorkLog(userId, {
			startedAt: new Date('2025-11-01T15:00:00Z'),
			endedAt: new Date('2025-11-01T17:00:00Z'),
			description: 'PJ-A機能開発',
		});
		await addWorkLogTag(workLog3.id, '開発');
		await addWorkLogTag(workLog3.id, 'PJ-A');
		workLogIds.push(workLog3.id);

		// 作業4: タグなし
		const workLog4 = await createWorkLog(userId, {
			startedAt: new Date('2025-11-01T18:00:00Z'),
			endedAt: new Date('2025-11-01T19:00:00Z'),
			description: 'その他の作業',
		});
		workLogIds.push(workLog4.id);
	});

	afterEach(async () => {
		// クリーンアップ
		for (const id of workLogIds) {
			await db.delete(workLogTags).where(eq(workLogTags.workLogId, id));
			await db.delete(workLogs).where(eq(workLogs.id, id));
		}
		workLogIds.length = 0;
	});

	it('TC1: 単一タグ「開発」で絞り込むと、該当する作業のみが取得される', async () => {
		const result = await listWorkLogs(userId, {
			tags: ['開発'],
			limit: 10,
			offset: 0,
		});

		// 「開発」タグが付いている作業は2件（作業1、作業3）
		expect(result).toHaveLength(2);
		expect(result[0].description).toBe('PJ-A機能開発'); // 降順なので最新が先
		expect(result[1].description).toBe('機能実装');

		// 各作業に「開発」タグが含まれている
		expect(result[0].tags).toContain('開発');
		expect(result[1].tags).toContain('開発');
	});

	it('TC2: 存在しないタグで絞り込むと、結果が0件', async () => {
		const result = await listWorkLogs(userId, {
			tags: ['存在しないタグ'],
			limit: 10,
			offset: 0,
		});

		expect(result).toHaveLength(0);
	});

	it('TC3: タグフィルタなしの場合、全ての作業が取得される', async () => {
		const result = await listWorkLogs(userId, {
			limit: 10,
			offset: 0,
		});

		// 全4件の作業が取得される
		expect(result).toHaveLength(4);
	});

	it('TC4: 空配列のタグフィルタは、フィルタなしと同じ', async () => {
		const result = await listWorkLogs(userId, {
			tags: [],
			limit: 10,
			offset: 0,
		});

		// 全4件の作業が取得される
		expect(result).toHaveLength(4);
	});
});
```

### 合格基準

- [ ] TC1: 単一タグで絞り込むと、該当する作業のみが取得される
- [ ] TC2: 存在しないタグで絞り込むと、結果が0件
- [ ] TC3: タグフィルタなしの場合、全ての作業が取得される
- [ ] TC4: 空配列のタグフィルタは、フィルタなしと同じ
- [ ] 既存の日付フィルタと組み合わせても正しく動作する

---

## ステップ2: タグ取得API

### 目的

ユーザーが過去に使用した全タグのリストを取得するAPIエンドポイントを作成する。これはサジェスト機能で使用する。

### 実装内容

#### 2.1 DB層: ユーザーのタグ一覧取得

**ファイル**: `src/db/workLogTags.ts`

```typescript
import { db } from './client';
import { workLogTags, workLogs } from './schema';
import { eq, sql } from 'drizzle-orm';

/**
 * ユーザーが使用した全タグのリストを取得（重複なし、アルファベット順）
 */
export const getUserTags = async (userId: string): Promise<string[]> => {
	const rows = await db
		.selectDistinct({ tag: workLogTags.tag })
		.from(workLogTags)
		.innerJoin(workLogs, eq(workLogTags.workLogId, workLogs.id))
		.where(eq(workLogs.userId, userId))
		.orderBy(workLogTags.tag);

	return rows.map((r) => r.tag);
};
```

#### 2.2 APIエンドポイント

**ファイル**: `src/routes/api/tags/+server.ts` (新規作成)

```typescript
import { json, error } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { getAuthenticatedUser } from '$lib/server/session';
import { getUserTags } from '$db/workLogTags';

export const GET: RequestHandler = async ({ locals }) => {
	// 認証確認
	const user = await getAuthenticatedUser(locals);
	if (!user) {
		throw error(401, 'Unauthorized');
	}

	try {
		// ユーザーのタグ一覧を取得
		const tags = await getUserTags(user.id);

		return json({ tags });
	} catch (err) {
		console.error('Failed to get user tags:', err);
		throw error(500, 'Internal Server Error');
	}
};
```

### テスト

#### UT-2.1: ユーザーのタグ一覧取得

**ファイル**: `src/db/workLogTags.spec.ts`

```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { getUserTags, addWorkLogTag } from './workLogTags';
import { createWorkLog } from './workLogs';
import { db } from './client';
import { workLogs, workLogTags } from './schema';
import { eq } from 'drizzle-orm';

describe('getUserTags', () => {
	const userId = 'test-user-get-tags';
	const workLogIds: string[] = [];

	beforeEach(async () => {
		// テストデータの作成
		const workLog1 = await createWorkLog(userId, {
			startedAt: new Date('2025-11-01T09:00:00Z'),
			description: '作業1',
		});
		await addWorkLogTag(workLog1.id, '開発');
		await addWorkLogTag(workLog1.id, 'PJ-A');
		workLogIds.push(workLog1.id);

		const workLog2 = await createWorkLog(userId, {
			startedAt: new Date('2025-11-01T10:00:00Z'),
			description: '作業2',
		});
		await addWorkLogTag(workLog2.id, '会議');
		await addWorkLogTag(workLog2.id, '開発'); // 重複
		workLogIds.push(workLog2.id);

		const workLog3 = await createWorkLog(userId, {
			startedAt: new Date('2025-11-01T11:00:00Z'),
			description: '作業3',
		});
		await addWorkLogTag(workLog3.id, 'レビュー');
		workLogIds.push(workLog3.id);
	});

	afterEach(async () => {
		// クリーンアップ
		for (const id of workLogIds) {
			await db.delete(workLogTags).where(eq(workLogTags.workLogId, id));
			await db.delete(workLogs).where(eq(workLogs.id, id));
		}
		workLogIds.length = 0;
	});

	it('TC1: ユーザーが使用した全タグが取得される（重複なし）', async () => {
		const tags = await getUserTags(userId);

		// 重複なしの4つのタグ
		expect(tags).toHaveLength(4);
		expect(tags).toContain('開発');
		expect(tags).toContain('PJ-A');
		expect(tags).toContain('会議');
		expect(tags).toContain('レビュー');
	});

	it('TC2: タグがアルファベット順（または五十音順）でソートされている', async () => {
		const tags = await getUserTags(userId);

		// アルファベット順
		expect(tags).toEqual(['PJ-A', 'レビュー', '会議', '開発']);
	});

	it('TC3: タグが1つもない場合、空配列が返る', async () => {
		const newUserId = 'user-without-tags';
		const workLog = await createWorkLog(newUserId, {
			startedAt: new Date('2025-11-01T09:00:00Z'),
			description: 'タグなし作業',
		});

		const tags = await getUserTags(newUserId);

		expect(tags).toEqual([]);

		// クリーンアップ
		await db.delete(workLogs).where(eq(workLogs.id, workLog.id));
	});
});
```

#### UT-2.2: APIエンドポイント

**ファイル**: `src/routes/api/tags/+server.spec.ts`

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { GET } from './+server';
import * as session from '$lib/server/session';
import * as workLogTagsDb from '$db/workLogTags';

vi.mock('$lib/server/session');
vi.mock('$db/workLogTags');

describe('GET /api/tags', () => {
	beforeEach(() => {
		vi.clearAllMocks();
	});

	it('TC1: 認証済みユーザーのタグ一覧が返される', async () => {
		// モック設定
		const mockUser = { id: 'user-123', githubId: 'github-123' };
		vi.mocked(session.getAuthenticatedUser).mockResolvedValue(mockUser);
		vi.mocked(workLogTagsDb.getUserTags).mockResolvedValue(['開発', '会議', 'PJ-A']);

		// リクエスト実行
		const response = await GET({ locals: {} as any });
		const data = await response.json();

		// 検証
		expect(session.getAuthenticatedUser).toHaveBeenCalledWith({});
		expect(workLogTagsDb.getUserTags).toHaveBeenCalledWith('user-123');
		expect(data).toEqual({ tags: ['開発', '会議', 'PJ-A'] });
	});

	it('TC2: 未認証の場合、401エラーが返る', async () => {
		// モック設定
		vi.mocked(session.getAuthenticatedUser).mockResolvedValue(null);

		// リクエスト実行と検証
		await expect(GET({ locals: {} as any })).rejects.toMatchObject({
			status: 401,
			body: { message: 'Unauthorized' },
		});
	});

	it('TC3: DB エラーの場合、500エラーが返る', async () => {
		// モック設定
		const mockUser = { id: 'user-123', githubId: 'github-123' };
		vi.mocked(session.getAuthenticatedUser).mockResolvedValue(mockUser);
		vi.mocked(workLogTagsDb.getUserTags).mockRejectedValue(new Error('DB Error'));

		// リクエスト実行と検証
		await expect(GET({ locals: {} as any })).rejects.toMatchObject({
			status: 500,
			body: { message: 'Internal Server Error' },
		});
	});
});
```

### 合格基準

- [ ] TC1: ユーザーが使用した全タグが取得される（重複なし）
- [ ] TC2: タグがソートされている
- [ ] TC3: タグが1つもない場合、空配列が返る
- [ ] TC4: API認証済みユーザーのタグ一覧が返される
- [ ] TC5: API未認証の場合、401エラーが返る
- [ ] TC6: APIのDBエラーの場合、500エラーが返る

---

## ステップ3: Server Load の拡張

### 目的

作業一覧ページの Server Load 関数で、URLパラメータから `tags` を取得し、DB層に渡す。また、タグ一覧もロード時に取得する。

### 実装内容

#### 3.1 Server Load の拡張

**ファイル**: `src/routes/+page.server.ts`

```typescript
import type { PageServerLoad } from './$types';
import { getAuthenticatedUser } from '$lib/server/session';
import { error } from '@sveltejs/kit';
import { listWorkLogs, getMonthlyTotal } from '$db/workLogs';
import { getUserTags } from '$db/workLogTags';
import dayjs from 'dayjs';
import utc from 'dayjs/plugin/utc';

dayjs.extend(utc);

export const load: PageServerLoad = async ({ locals, url }) => {
	// 認証確認
	const user = await getAuthenticatedUser(locals);
	if (!user) {
		throw error(401, 'Unauthorized');
	}

	// ... 既存の日付フィルタ処理（month, date, from, to）

	// タグフィルタの取得（新規）
	const tagsParam = url.searchParams.get('tags');
	const tags = tagsParam
		? tagsParam
				.split(',')
				.map((t) => t.trim())
				.filter((t) => t.length > 0 && t.length <= 100)
				.slice(0, 10) // 最大10個
		: undefined;

	// ページング
	const page = Math.max(1, Number(url.searchParams.get('page')) || 1);
	const size = Math.min(100, Math.max(10, Number(url.searchParams.get('size')) || 20));

	// 作業記録の取得（タグフィルタを追加）
	const workLogs = await listWorkLogs(user.id, {
		from,
		to,
		tags, // 追加
		limit: size + 1,
		offset: (page - 1) * size,
	});

	const hasNext = workLogs.length > size;
	const items = workLogs.slice(0, size);

	// 月次合計の計算
	// ... 既存の処理

	// タグ一覧の取得（新規）
	const availableTags = await getUserTags(user.id);

	return {
		items: items.map((log) => ({
			id: log.id,
			startedAt: log.startedAt.toISOString(),
			endedAt: log.endedAt?.toISOString() || null,
			description: log.description,
			tags: log.tags, // 追加
			durationSec: log.durationSec,
		})),
		page,
		size,
		hasNext,
		serverNow: new Date().toISOString(),
		monthlyTotalSec,
		availableTags, // 追加
	};
};
```

### テスト

#### UT-3.1: Server Load のタグフィルタ

**ファイル**: `src/routes/+page.server.spec.ts`

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { load } from './+page.server';
import * as session from '$lib/server/session';
import * as workLogsDb from '$db/workLogs';
import * as workLogTagsDb from '$db/workLogTags';
import { WorkLog } from '$models/WorkLog';

vi.mock('$lib/server/session');
vi.mock('$db/workLogs');
vi.mock('$db/workLogTags');

describe('PageServerLoad - タグフィルタ', () => {
	const mockUser = { id: 'user-123', githubId: 'github-123' };

	beforeEach(() => {
		vi.clearAllMocks();
		vi.mocked(session.getAuthenticatedUser).mockResolvedValue(mockUser);
		vi.mocked(workLogsDb.getMonthlyTotal).mockResolvedValue(0);
		vi.mocked(workLogTagsDb.getUserTags).mockResolvedValue(['開発', '会議', 'PJ-A']);
	});

	it('TC1: URLに tags パラメータがある場合、タグフィルタが適用される', async () => {
		// モック設定
		const mockWorkLog = WorkLog.reconstruct({
			id: 'log-1',
			userId: 'user-123',
			startedAt: new Date('2025-11-01T09:00:00Z'),
			endedAt: new Date('2025-11-01T11:00:00Z'),
			description: '開発作業',
			tags: ['開発'],
			createdAt: new Date(),
			updatedAt: new Date(),
		});
		vi.mocked(workLogsDb.listWorkLogs).mockResolvedValue([mockWorkLog]);

		// URL作成
		const url = new URL('http://localhost?tags=開発');

		// 実行
		const result = await load({
			locals: {} as any,
			url,
		} as any);

		// 検証
		expect(workLogsDb.listWorkLogs).toHaveBeenCalledWith('user-123', {
			from: expect.any(Date),
			to: expect.any(Date),
			tags: ['開発'], // タグフィルタが渡されている
			limit: 21,
			offset: 0,
		});

		expect(result.items).toHaveLength(1);
		expect(result.items[0].tags).toContain('開発');
		expect(result.availableTags).toEqual(['開発', '会議', 'PJ-A']);
	});

	it('TC2: 複数タグがカンマ区切りで渡された場合、配列として処理される', async () => {
		vi.mocked(workLogsDb.listWorkLogs).mockResolvedValue([]);

		const url = new URL('http://localhost?tags=開発,会議,PJ-A');

		await load({
			locals: {} as any,
			url,
		} as any);

		expect(workLogsDb.listWorkLogs).toHaveBeenCalledWith('user-123', {
			from: expect.any(Date),
			to: expect.any(Date),
			tags: ['開発', '会議', 'PJ-A'],
			limit: 21,
			offset: 0,
		});
	});

	it('TC3: 空白や空文字のタグは無視される', async () => {
		vi.mocked(workLogsDb.listWorkLogs).mockResolvedValue([]);

		const url = new URL('http://localhost?tags=開発,,  ,会議');

		await load({
			locals: {} as any,
			url,
		} as any);

		expect(workLogsDb.listWorkLogs).toHaveBeenCalledWith('user-123', {
			from: expect.any(Date),
			to: expect.any(Date),
			tags: ['開発', '会議'], // 空白・空文字は除外
			limit: 21,
			offset: 0,
		});
	});

	it('TC4: 11個以上のタグが指定された場合、最初の10個のみ使用される', async () => {
		vi.mocked(workLogsDb.listWorkLogs).mockResolvedValue([]);

		const tags = Array.from({ length: 15 }, (_, i) => `tag${i + 1}`).join(',');
		const url = new URL(`http://localhost?tags=${tags}`);

		await load({
			locals: {} as any,
			url,
		} as any);

		const calledTags = vi.mocked(workLogsDb.listWorkLogs).mock.calls[0][1].tags;
		expect(calledTags).toHaveLength(10);
	});

	it('TC5: tagsパラメータがない場合、tagsはundefinedで渡される', async () => {
		vi.mocked(workLogsDb.listWorkLogs).mockResolvedValue([]);

		const url = new URL('http://localhost');

		await load({
			locals: {} as any,
			url,
		} as any);

		expect(workLogsDb.listWorkLogs).toHaveBeenCalledWith('user-123', {
			from: expect.any(Date),
			to: expect.any(Date),
			tags: undefined,
			limit: 21,
			offset: 0,
		});
	});
});
```

### 合格基準

- [ ] TC1: URLに tags パラメータがある場合、タグフィルタが適用される
- [ ] TC2: 複数タグがカンマ区切りで渡された場合、配列として処理される
- [ ] TC3: 空白や空文字のタグは無視される
- [ ] TC4: 11個以上のタグが指定された場合、最初の10個のみ使用される
- [ ] TC5: tagsパラメータがない場合、tagsはundefinedで渡される
- [ ] availableTagsがロード時に取得される

---

## ステップ4: UI実装 - TagInput コンポーネント

### 目的

タグ入力欄とサジェスト機能を持つコンポーネントを作成する。

### 実装内容

#### 4.1 TagInput コンポーネント

**ファイル**: `src/lib/components/TagInput/TagInput.svelte` (新規作成)

```svelte
<script lang="ts">
	import { createEventDispatcher } from 'svelte';

	type Props = {
		/** 選択されているタグのリスト */
		tags?: string[];
		/** サジェスト候補のタグリスト */
		suggestions?: string[];
		/** プレースホルダー */
		placeholder?: string;
	};

	let { tags = [], suggestions = [], placeholder = 'タグを入力...' }: Props = $props();

	const dispatch = createEventDispatcher<{
		change: string[];
	}>();

	let inputValue = $state('');
	let showSuggestions = $state(false);
	let selectedIndex = $state(-1);

	// 入力値に基づいてフィルタリングされたサジェスト
	$effect(() => {
		if (inputValue.trim()) {
			filteredSuggestions = suggestions.filter(
				(s) => !tags.includes(s) && s.toLowerCase().includes(inputValue.toLowerCase()),
			);
		} else {
			filteredSuggestions = suggestions.filter((s) => !tags.includes(s));
		}
	});

	let filteredSuggestions = $state<string[]>([]);

	const addTag = (tag: string) => {
		if (tag && !tags.includes(tag)) {
			dispatch('change', [...tags, tag]);
			inputValue = '';
			selectedIndex = -1;
		}
	};

	const removeTag = (tag: string) => {
		dispatch(
			'change',
			tags.filter((t) => t !== tag),
		);
	};

	const handleKeyDown = (e: KeyboardEvent) => {
		if (e.key === 'Enter' && inputValue.trim()) {
			e.preventDefault();
			if (selectedIndex >= 0 && filteredSuggestions[selectedIndex]) {
				addTag(filteredSuggestions[selectedIndex]);
			} else {
				addTag(inputValue.trim());
			}
		} else if (e.key === 'Backspace' && !inputValue && tags.length > 0) {
			removeTag(tags[tags.length - 1]);
		} else if (e.key === 'ArrowDown') {
			e.preventDefault();
			selectedIndex = Math.min(selectedIndex + 1, filteredSuggestions.length - 1);
		} else if (e.key === 'ArrowUp') {
			e.preventDefault();
			selectedIndex = Math.max(selectedIndex - 1, -1);
		} else if (e.key === 'Escape') {
			showSuggestions = false;
			selectedIndex = -1;
		}
	};

	const handleFocus = () => {
		showSuggestions = true;
	};

	const handleBlur = () => {
		// サジェストのクリックを有効にするため、少し遅延させる
		setTimeout(() => {
			showSuggestions = false;
			selectedIndex = -1;
		}, 200);
	};
</script>

<div class="form-control">
	<label class="label">
		<span class="label-text">タグで絞り込み</span>
	</label>

	<!-- 選択されたタグのバッジ -->
	{#if tags.length > 0}
		<div class="mb-2 flex flex-wrap gap-2">
			{#each tags as tag}
				<div class="badge gap-2 badge-primary">
					{tag}
					<button
						type="button"
						class="btn btn-ghost btn-xs"
						onclick={() => removeTag(tag)}
						aria-label={`${tag}を削除`}
					>
						×
					</button>
				</div>
			{/each}
		</div>
	{/if}

	<!-- 入力欄 -->
	<div class="relative">
		<input
			type="text"
			bind:value={inputValue}
			{placeholder}
			class="input-bordered input w-full"
			onfocus={handleFocus}
			onblur={handleBlur}
			onkeydown={handleKeyDown}
		/>

		<!-- サジェストリスト -->
		{#if showSuggestions && filteredSuggestions.length > 0}
			<ul class="menu absolute z-10 mt-1 w-full rounded-box bg-base-100 shadow-lg">
				{#each filteredSuggestions.slice(0, 10) as suggestion, i}
					<li>
						<button
							type="button"
							class:active={i === selectedIndex}
							onclick={() => addTag(suggestion)}
						>
							{suggestion}
						</button>
					</li>
				{/each}
			</ul>
		{/if}
	</div>
</div>
```

### テスト

#### UT-4.1: TagInput コンポーネント

**ファイル**: `src/lib/components/TagInput/TagInput.svelte.spec.ts`

```typescript
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/svelte';
import userEvent from '@testing-library/user-event';
import TagInput from './TagInput.svelte';

describe('TagInput', () => {
	it('TC1: タグを入力してEnterを押すと、タグが追加される', async () => {
		const handleChange = vi.fn();
		const user = userEvent.setup();

		render(TagInput, {
			props: {
				tags: [],
				suggestions: ['開発', '会議', 'PJ-A'],
			},
			on: {
				change: handleChange,
			},
		});

		const input = screen.getByPlaceholderText('タグを入力...');
		await user.type(input, '開発{Enter}');

		expect(handleChange).toHaveBeenCalledWith(
			expect.objectContaining({
				detail: ['開発'],
			}),
		);
	});

	it('TC2: サジェストをクリックすると、タグが追加される', async () => {
		const handleChange = vi.fn();
		const user = userEvent.setup();

		render(TagInput, {
			props: {
				tags: [],
				suggestions: ['開発', '会議', 'PJ-A'],
			},
			on: {
				change: handleChange,
			},
		});

		const input = screen.getByPlaceholderText('タグを入力...');
		await user.click(input); // フォーカスしてサジェスト表示

		const suggestion = screen.getByText('開発');
		await user.click(suggestion);

		expect(handleChange).toHaveBeenCalledWith(
			expect.objectContaining({
				detail: ['開発'],
			}),
		);
	});

	it('TC3: タグバッジの×ボタンをクリックすると、タグが削除される', async () => {
		const handleChange = vi.fn();
		const user = userEvent.setup();

		render(TagInput, {
			props: {
				tags: ['開発', '会議'],
				suggestions: [],
			},
			on: {
				change: handleChange,
			},
		});

		const removeButton = screen.getAllByLabelText(/を削除/)[0]; // 「開発を削除」
		await user.click(removeButton);

		expect(handleChange).toHaveBeenCalledWith(
			expect.objectContaining({
				detail: ['会議'], // 「開発」が削除された
			}),
		);
	});

	it('TC4: 入力欄が空の状態でBackspaceを押すと、最後のタグが削除される', async () => {
		const handleChange = vi.fn();
		const user = userEvent.setup();

		render(TagInput, {
			props: {
				tags: ['開発', '会議'],
				suggestions: [],
			},
			on: {
				change: handleChange,
			},
		});

		const input = screen.getByPlaceholderText('タグを入力...');
		await user.click(input);
		await user.keyboard('{Backspace}');

		expect(handleChange).toHaveBeenCalledWith(
			expect.objectContaining({
				detail: ['開発'], // 「会議」が削除された
			}),
		);
	});

	it('TC5: 矢印キーでサジェストを選択し、Enterで追加できる', async () => {
		const handleChange = vi.fn();
		const user = userEvent.setup();

		render(TagInput, {
			props: {
				tags: [],
				suggestions: ['開発', '会議', 'PJ-A'],
			},
			on: {
				change: handleChange,
			},
		});

		const input = screen.getByPlaceholderText('タグを入力...');
		await user.click(input); // サジェスト表示
		await user.keyboard('{ArrowDown}'); // 1つ目を選択
		await user.keyboard('{Enter}');

		expect(handleChange).toHaveBeenCalledWith(
			expect.objectContaining({
				detail: ['開発'],
			}),
		);
	});

	it('TC6: Escapeキーでサジェストを閉じる', async () => {
		const user = userEvent.setup();

		render(TagInput, {
			props: {
				tags: [],
				suggestions: ['開発', '会議', 'PJ-A'],
			},
		});

		const input = screen.getByPlaceholderText('タグを入力...');
		await user.click(input); // サジェスト表示

		expect(screen.getByText('開発')).toBeInTheDocument();

		await user.keyboard('{Escape}');

		// サジェストが非表示になる（注: このテストは実装依存）
		await new Promise((r) => setTimeout(r, 100));
		expect(screen.queryByText('開発')).not.toBeVisible();
	});

	it('TC7: 入力値でサジェストがフィルタリングされる', async () => {
		const user = userEvent.setup();

		render(TagInput, {
			props: {
				tags: [],
				suggestions: ['開発', '会議', 'PJ-A', 'PJ-B'],
			},
		});

		const input = screen.getByPlaceholderText('タグを入力...');
		await user.type(input, 'PJ');

		// 「PJ」を含むサジェストのみ表示
		expect(screen.getByText('PJ-A')).toBeInTheDocument();
		expect(screen.getByText('PJ-B')).toBeInTheDocument();
		expect(screen.queryByText('開発')).not.toBeInTheDocument();
		expect(screen.queryByText('会議')).not.toBeInTheDocument();
	});
});
```

### 合格基準

- [ ] TC1: タグを入力してEnterを押すと、タグが追加される
- [ ] TC2: サジェストをクリックすると、タグが追加される
- [ ] TC3: タグバッジの×ボタンをクリックすると、タグが削除される
- [ ] TC4: 入力欄が空の状態でBackspaceを押すと、最後のタグが削除される
- [ ] TC5: 矢印キーでサジェストを選択し、Enterで追加できる
- [ ] TC6: Escapeキーでサジェストを閉じる
- [ ] TC7: 入力値でサジェストがフィルタリングされる

---

## ステップ5: ページ統合

### 目的

作業一覧ページに TagInput コンポーネントを統合し、タグフィルタが動作するようにする。

### 実装内容

#### 5.1 ページコンポーネントの修正

**ファイル**: `src/routes/+page.svelte`

```svelte
<script lang="ts">
	import { goto } from '$app/navigation';
	import { page } from '$app/stores';
	import TagInput from '$lib/components/TagInput/TagInput.svelte';
	import TagBadge from '$lib/components/TagBadge/TagBadge.svelte';

	export let data;

	// URLから選択中のタグを取得
	$: selectedTags = $page.url.searchParams.get('tags')?.split(',').filter(Boolean) || [];

	// タグ変更ハンドラ
	const handleTagsChange = (event: CustomEvent<string[]>) => {
		const tags = event.detail;
		const url = new URL($page.url);

		if (tags.length > 0) {
			url.searchParams.set('tags', tags.join(','));
		} else {
			url.searchParams.delete('tags');
		}

		// ページをリセット
		url.searchParams.set('page', '1');

		goto(url.toString(), { replaceState: false });
	};

	// 一覧のタグバッジクリックハンドラ
	const handleTagClick = (tag: string) => {
		if (!selectedTags.includes(tag)) {
			handleTagsChange({ detail: [...selectedTags, tag] } as CustomEvent<string[]>);
		}
	};
</script>

<div class="container mx-auto p-4">
	<!-- フィルタバー -->
	<div class="mb-6 rounded-lg bg-base-200 p-4">
		<h2 class="mb-4 text-lg font-bold">絞り込み</h2>

		<!-- 日付フィルタ（既存） -->
		<!-- ... -->

		<!-- タグフィルタ（新規） -->
		<TagInput
			tags={selectedTags}
			suggestions={data.availableTags || []}
			on:change={handleTagsChange}
		/>
	</div>

	<!-- 作業一覧 -->
	<div class="space-y-4">
		{#each data.items as workLog}
			<div class="card bg-base-100 shadow-md">
				<div class="card-body">
					<!-- 作業情報 -->
					<div class="flex justify-between">
						<div>
							<p class="text-sm text-base-content/60">
								{new Date(workLog.startedAt).toLocaleDateString('ja-JP')}
							</p>
							<p class="text-lg font-semibold">
								{workLog.description || '(作業内容なし)'}
							</p>
						</div>
						<div class="text-right">
							<!-- 作業時間表示 -->
						</div>
					</div>

					<!-- タグ表示 -->
					{#if workLog.tags && workLog.tags.length > 0}
						<div class="mt-2 flex flex-wrap gap-2">
							{#each workLog.tags as tag}
								<button onclick={() => handleTagClick(tag)}>
									<TagBadge {tag} clickable />
								</button>
							{/each}
						</div>
					{/if}
				</div>
			</div>
		{/each}
	</div>
</div>
```

#### 5.2 TagBadge の拡張（クリック可能）

**ファイル**: `src/lib/components/TagBadge/TagBadge.svelte`

```svelte
<script lang="ts">
	type Props = {
		tag: string;
		clickable?: boolean;
		removable?: boolean;
		onRemove?: () => void;
	};

	let { tag, clickable = false, removable = false, onRemove }: Props = $props();
</script>

<span
	class="badge gap-2 badge-primary"
	class:cursor-pointer={clickable}
	class:hover:badge-secondary={clickable}
>
	{tag}
	{#if removable && onRemove}
		<button
			type="button"
			class="btn btn-ghost btn-xs"
			onclick={onRemove}
			aria-label={`${tag}を削除`}
		>
			×
		</button>
	{/if}
</span>
```

### テスト

#### E2E-5.1: タグフィルタリングフロー

**ファイル**: `e2e/tag-filter.test.ts` (新規作成)

```typescript
import { test, expect } from '@playwright/test';

test.describe('タグでの絞り込み（UC-001）', () => {
	test.beforeEach(async ({ page }) => {
		// ログイン処理
		await page.goto('/');
		// ... 認証処理
	});

	test('TC1: タグ入力欄にタグを入力してEnterを押すと、フィルタリングされる', async ({ page }) => {
		// タグ入力欄に「開発」と入力
		await page.fill('input[placeholder="タグを入力..."]', '開発');
		await page.keyboard.press('Enter');

		// URLに ?tags=開発 が追加される
		await expect(page).toHaveURL(/tags=開発/);

		// 選択されたタグバッジが表示される
		await expect(page.locator('.badge:has-text("開発")')).toBeVisible();

		// 「開発」タグが付いた作業のみが表示される
		const workLogs = page.locator('.card');
		const count = await workLogs.count();
		expect(count).toBeGreaterThan(0);

		// 各作業に「開発」タグが含まれている
		for (let i = 0; i < count; i++) {
			await expect(workLogs.nth(i).locator('.badge:has-text("開発")')).toBeVisible();
		}
	});

	test('TC2: サジェストから選択してフィルタリングできる', async ({ page }) => {
		// タグ入力欄をクリックしてサジェスト表示
		await page.click('input[placeholder="タグを入力..."]');

		// サジェストリストが表示される
		await expect(page.locator('.menu')).toBeVisible();

		// 「会議」をクリック
		await page.click('.menu button:has-text("会議")');

		// URLに ?tags=会議 が追加される
		await expect(page).toHaveURL(/tags=会議/);

		// 「会議」タグが付いた作業のみが表示される
		const workLogs = page.locator('.card');
		const count = await workLogs.count();

		for (let i = 0; i < count; i++) {
			await expect(workLogs.nth(i).locator('.badge:has-text("会議")')).toBeVisible();
		}
	});

	test('TC3: 一覧のタグバッジをクリックすると、そのタグでフィルタリングされる', async ({
		page,
	}) => {
		// 最初の作業のタグバッジをクリック
		const firstWorkLog = page.locator('.card').first();
		const tagBadge = firstWorkLog.locator('.badge').first();
		const tagText = await tagBadge.textContent();

		await tagBadge.click();

		// URLにタグが追加される
		await expect(page).toHaveURL(new RegExp(`tags=${tagText}`));

		// そのタグが付いた作業のみが表示される
		const workLogs = page.locator('.card');
		const count = await workLogs.count();

		for (let i = 0; i < count; i++) {
			await expect(workLogs.nth(i).locator(`.badge:has-text("${tagText}")`)).toBeVisible();
		}
	});

	test('TC4: タグバッジの×ボタンでフィルタを解除できる', async ({ page }) => {
		// タグでフィルタリング
		await page.fill('input[placeholder="タグを入力..."]', '開発');
		await page.keyboard.press('Enter');

		await expect(page).toHaveURL(/tags=開発/);

		// タグバッジの×ボタンをクリック
		await page.click('.badge:has-text("開発") button');

		// URLからタグが削除される
		await expect(page).not.toHaveURL(/tags=/);

		// 全ての作業が表示される
		const workLogs = page.locator('.card');
		const count = await workLogs.count();
		expect(count).toBeGreaterThan(0);
	});

	test('TC5: 存在しないタグでフィルタリングすると、結果が0件', async ({ page }) => {
		// 存在しないタグを入力
		await page.fill('input[placeholder="タグを入力..."]', '存在しないタグ');
		await page.keyboard.press('Enter');

		await expect(page).toHaveURL(/tags=存在しないタグ/);

		// 作業が表示されない
		await expect(page.locator('.card')).toHaveCount(0);

		// 「該当する作業がありません」のようなメッセージが表示される（実装による）
		await expect(page.locator('text=該当する作業がありません')).toBeVisible();
	});
});
```

### 合格基準

- [ ] TC1: タグ入力欄にタグを入力してEnterを押すと、フィルタリングされる
- [ ] TC2: サジェストから選択してフィルタリングできる
- [ ] TC3: 一覧のタグバッジをクリックすると、そのタグでフィルタリングされる
- [ ] TC4: タグバッジの×ボタンでフィルタを解除できる
- [ ] TC5: 存在しないタグでフィルタリングすると、結果が0件

---

## 全体の合格基準

### 機能要件

- [ ] 単一タグで作業記録を絞り込める
- [ ] URLパラメータにタグが反映される（`?tags=開発`）
- [ ] 選択されたタグがバッジとして表示される
- [ ] タグ入力でサジェストが表示される
- [ ] サジェストから選択できる
- [ ] 一覧のタグバッジをクリックしてフィルタリングできる
- [ ] タグバッジの×ボタンでフィルタを解除できる
- [ ] 存在しないタグでフィルタリングすると結果が0件

### 非機能要件

- [ ] タグフィルタと日付フィルタを組み合わせて使用できる
- [ ] キーボードのみで操作できる
- [ ] レスポンシブデザイン（モバイルでも使いやすい）
- [ ] アクセシブル（ARIAラベル、スクリーンリーダー対応）

### テストカバレッジ

- [ ] 全ての単体テストが合格
- [ ] 全てのE2Eテストが合格
- [ ] コードカバレッジ80%以上

## 次のステップ

UC-001の実装が完了したら、次のユースケースに進みます:

- **UC-002**: 複数タグで絞り込む（AND条件）
- **UC-003**: 一覧のタグバッジから絞り込む（UC-001で一部実装済み）
- **UC-004**: タグフィルタを解除（UC-001で実装済み）
- **UC-005**: 日付とタグを組み合わせて絞り込む

---

## 備考

- Svelte 5の `$props` と `$state` を使用
- Tailwind CSS + daisyUI でスタイリング
- Drizzle ORM のAPIに応じてクエリを調整
- サジェストのパフォーマンス最適化（デバウンス）は後続タスクで実装
